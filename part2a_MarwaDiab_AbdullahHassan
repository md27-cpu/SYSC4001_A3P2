

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <string.h>
#include <time.h>

#define MAX_LINES 5
#define MAX_EXAM_SIZE 256
#define MAX_RUBRIC_SIZE 256

typedef struct {
    char rubric[MAX_LINES][MAX_RUBRIC_SIZE];
    char examContent[MAX_EXAM_SIZE];
    int examDone;          // 1 if exma fully marked
    int studentNumber;     // extracted from exam file (4digits student nmbr)
    int currentQuestion;   // which question TAs should mark next
} SharedData;

void load_rubric(SharedData *data) {
    FILE *f = fopen("rubric.txt", "r");
    if (!f) { perror("rubric.txt"); exit(1); }

    for (int i = 0; i < MAX_LINES; i++) {
        fgets(data->rubric[i], MAX_RUBRIC_SIZE, f);
        data->rubric[i][strcspn(data->rubric[i], "\n")] = '\0';
    }
    fclose(f);
}

void save_rubric(SharedData *data) {
    FILE *f = fopen("rubric.txt", "w");
    if (!f) { perror("rubric.txt"); exit(1); }

    for (int i = 0; i < MAX_LINES; i++)
        fprintf(f, "%s\n", data->rubric[i]);

    fclose(f);
}

void load_exam(SharedData *data, char *filename) {
    FILE *f = fopen(filename, "r");
    if (!f) { perror("exam file"); exit(1); }

    fgets(data->examContent, MAX_EXAM_SIZE, f);
    data->examContent[strcspn(data->examContent, "\n")] = '\0';

    data->studentNumber = atoi(data->examContent);
    data->examDone = 0;
    data->currentQuestion = 0;

    fclose(f);
}

void TA_process(int id, SharedData *data, char examFiles[][32], int examCount) {

    int examIndex = 0;

    while (1) {
        if (examIndex >= examCount) break;

        load_exam(data, examFiles[examIndex]);
        int stu = data->studentNumber;

        printf("TA %d: Loaded exam for student %d\n", id, stu);
        fflush(stdout);

        if (stu == 9999) {
            printf("TA %d: Terminating (student 9999)\n", id);
            exit(0);
        }

        // chedk rubric
        for (int i = 0; i < MAX_LINES; i++) {
            int needFix = rand() % 2; // random decision
            usleep((500 + rand() % 500) * 1000); // 0.5–1.0 sec

            if (needFix) {
                printf("TA %d: Correcting rubric line %d\n", id, i+1);
                data->rubric[i][3] = data->rubric[i][3] + 1; // next ASCII char
                save_rubric(data);
            } else {
                printf("TA %d: Checked rubric line %d\n", id, i+1);
            }
        }

        //marking
        while (data->currentQuestion < MAX_LINES) {
            int q = data->currentQuestion;
            data->currentQuestion++;

            printf("TA %d: Marking question %d for student %d\n", id, q+1, stu);
            fflush(stdout);

            usleep((1000 + rand() % 1000) * 1000); // 1–2 sec
        }

        printf("TA %d: Finished exam for student %d\n", id, stu);

        examIndex++;
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <num_TAs>\n", argv[0]);
        exit(1);
    }

    int numTAs = atoi(argv[1]);
    if (numTAs < 2) {
        fprintf(stderr, "Need at least 2 TAs.\n");
        exit(1);
    }

    srand(time(NULL));

    key_t key = ftok(".", 65);
    int shmid = shmget(key, sizeof(SharedData), 0666 | IPC_CREAT);
    SharedData *data = (SharedData *)shmat(shmid, NULL, 0);

    load_rubric(data);

    // List exam files
    char examFiles[20][32];
    int examCount = 0;

    for (int i = 1; i <= 20; i++) {
        sprintf(examFiles[examCount], "exam_%04d.txt", i);
        examCount++;
    }

    //final terminating exam file with student 9999
    strcpy(examFiles[examCount], "exam_9999.txt");
    examCount++;

    // Fork TA processes cuz multiple TA
    for (int i = 0; i < numTAs; i++) {
        if (fork() == 0) {
            TA_process(i + 1, data, examFiles, examCount);
            exit(0);
        }
    }

    for (int i = 0; i < numTAs; i++) wait(NULL);

    shmdt(data);
    shmctl(shmid, IPC_RMID, NULL);

    return 0;
}
